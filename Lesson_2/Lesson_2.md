# Добавление стрельбы

На этом занятии мы добавим возможность стрельбы по щелчку мыши.

Для начала давайте сделаем так, чтобы игра могла замечать наши нажатия на кнопку мыши. Это будет наш первый опыт работы с обработчиком событий.

```python
def handle_events(self):    # Метод handle_events класса Game
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
        	sys.exit()
        if event.type == pygame.MOUSEBUTTONDOWN: # <--- Нажатие на кнопку мыши
            self.mouse_pressed = True            # <--- Сохраняем состояние кнопки
        if event.type == pygame.MOUSEBUTTONUP:   # <--- Отпускание кнопки мыши
            self.mouse_pressed = False           # <--- Сохраняем состояние кнопки
```

Здесь мы добавили **2 новых обработчика событий**: обработчик нажатия на кнопку и обработчик отпускания кнопки. Мы привыкли воспринимать клик мышкой как единое событие, но на самом деле это не так. Такое поведение очень полезно для регистрации долгих нажатий, например в drag-and-drop интерфейсах. При нажатии на кнопку мыши обработчик распознает событие *event* как *pygame.MOUSEBUTTONDOWN* и код внутри условия выполнится. Поскольку мы хотим, чтобы при долгом нажатии звездолёт продолжал стрелять, нам необходимо сохранить состояние кнопки в атрибут *self.mouse_pressed*. Мы ещё не объявили данный атрибут, но сейчас это сделаем.

```python
def __init__(self, screen):     # Конструктор класса Game
    self.screen = screen
    self.starship = Starship()
    self.bullets = []
    self.asteroids = []
    self.mouse_pressed = False  # <------  Cохраняет состояние кнопки мыши
```

Теперь мы можем регистрировать нажатия на кнопки мыши. Давайте сделаем так, чтобы игра могла реагировать на это.

```python
def handle_events(self):    # Метод handle_events класса Game
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
        	sys.exit()
        if event.type == pygame.MOUSEBUTTONDOWN:
            self.mouse_pressed = True           
        if event.type == pygame.MOUSEBUTTONUP:   
            self.mouse_pressed = False
    if self.mouse_pressed:                 # Если кнопка мыши нажата...
        new_bullet = self.starship.fire()  # ...создать новую пулю...
    	self.bullets.append(new_bullet)    # ...и добавить её в список всех пуль
```

Теперь, при условии того, что кнопка мыши нажата, мы создаём новый объект пули при помощи **метода объекта класса Starship** и добавляем его в общий список для пуль. Давайте быстро опишем данный метод.

```python
def fire(self):                     # Метод fire класса Starship
    return Bullet(self.pos.copy())  # Создание новой пули на том же месте где находится игрок
```

Мы опишем класс *Bullet* чуть позже, но у вас уже мог возникнуть вопрос: почему бы нам не создать объект пули прямо внутри метода *Game.handle_events*? На данном этапе можно сделать и так, но очень скоро мы свяжем очень важное действие с созданием объекта класса *Bullet*, именно поэтому мы сделали для этого отдельный метод. Вы также должны были заметить, что мы передаём **копию** координат звездолёта, а не сами координаты. Мы разберём зачем это нужно после того как опишем класс *Bullet*.

Реализация этого класса будет очень похожа на класс *Starship*, но тем не менее будет немного проще, так как логика поведения пуль довольно простая.

```python
class Bullet:
    # Объектов класса Bullet будет создаваться довольно много, поэтому мы
    # хотим загрузить картинку толлько 1 раз
    original_image = pygame.image.load(os.path.join("images", "bullet.png"))
    def __init__(self, pos):
        self.pos = pos
        # Направление пули не изменяется с течением времени, поэтому его можно
        # вычислить внутри конструктора
        mouse_pos = pygame.mouse.get_pos()
        self.direction = (mouse_pos - pos)
        self.speed = self.direction / max(abs(self.direction)) * 10
        # Угол также не изменяется
        self.angle = self.calculate_angle(mouse_pos)  # Расчёт угла поворота
        # Угол не изменяется, поэтому картинку тоже можно повернуть сразу в конструкторе
        self.image = pygame.transform.rotate(self.original_image, int(self.angle))
        self.rect = self.image.get_rect(center=self.pos) # Получение хитбокса

    def move(self):
        self.pos += self.speed
        self.rect = self.image.get_rect(center=self.pos)

    def calculate_angle(self, mouse_pos):
        rel_x, rel_y = mouse_pos - self.pos
        angle = (180 / math.pi) * -math.atan2(rel_y, rel_x) + 90
        return angle
```

Давайте разберём код. Главное отличие от класса *Starship* состоит в том, что поведение пули в процессе полёта никак не зависит от игрока. После выстрела скорость, угол поворота, направление и картинка не изменяются, поэтому мы должны расчитать эти атрибуты **всего 1 раз**. Удобнее всего сделать это в конструкторе класса. Ранее изученные моменты вроде расчёта угла поворота не будут разобраны, поэтому если вы чувствуете, что забыли, что делает тот или иной код, то можете заглянуть в конспект предыдущего урока.

Обратите внимание, что мы сохраняем *original_image* в качестве атрибута **класса** *Bullet*. Это значит, что загрузка картинки произойдёт **только 1 раз** &mdash; в момент создания класса.  То есть нам не придётся загружать картинку каждый раз при создании пули.

*self.pos* &mdash; координаты пули, задаются равными единственному аргументу, который принимает конструктор класса *Bullet*. При создании пуль мы будем передавать в конструктор текущую позицию звездолёта (*Starship.pos*). Ранее я упомянул, что мы должны передать **копию** позиции звездолёта. В случае передачи оригинальной позиции, методы объекта класса ***Bullet*** будут способны изменить позицию ***звездолёта***, а это крайне нежелательный эффект. Попробуйте убрать копирование после того как мы реализуем стрельбу и посмотрите, что произойдёт.

*self.speed* &mdash; расчёт скорости пули. Заметьте, что он отличается от расчёта в *Starship.move*, где мы расчитывали скорость следующим образом &mdash; *self.speed = direction / 40*. Деление направления на модуль максимальной координаты направления (*max(abs(self.direction))*) необходимо для получения вектора направления, величина которого не зависит от расстояния до курсора. Это позволит нам сохранить скорость пули постоянной, а при помощи умножения на число можно непосредственно задавать величину скорости. Для того чтобы уловить различия на практике попробуйте заменить данное выражение на *self.speed = direction / 40*.

Определения атрибутов *angle*, *image* и *rect* не отличаются от разобранных ранее. 

```python
def move(self):      # Метод move класса Bullet
    self.pos += self.speed
    self.rect = self.image.get_rect(center=self.pos)
```

Метод *move* в данном случае очень простой, всё что он делает это перемещение объекта в направлении вектора скорости и обновление хитбокса.

Метод *calculate angle* мы просто скопировали из класса *Starship*, так как нам нужен тот же самый функционал.

Для того чтобы всё, наконец, заработало, мы добавим списки с пулями в вызовы методов *Game.move_objects* и *Game.draw* в главном цикле.

```python
def run(self):     # Метод run класса Game
    while True:
        self.handle_events()
        self.move_objects([[self.starship], self.bullets])
        self.draw([[self.starship], self.bullets])
```

При запуске игры и при нажатии кнопки мыши мы увидим следующую картину:

![image-20210327111600737](/home/roman/.config/Typora/typora-user-images/image-20210327111600737.png) 

Данная реализация имеет две основных проблемы:

* Если держать кнопку мыши нажатой, то пули вылетаю слишком часто (на каждом кадре).
* Пули не исчезают после того как выходят за пределы экрана, но игра продолжает обрабатывать их поведение. Через некоторое время их станет слишком много и игра начнёт сильно тормозить. Чтобы убедиться в том, что пули не исчезают, попробуйте вывести на печать длину *self.bullets* в главном цикле игры.

# Оптимизация стрельбы

Давайте исправим эти проблемы. Для начала сделаем так, чтобы пули исчезали при выходе за границы экрана. 

Для этого мы реализуем метод *check_collisions* в классе *Game*, который будет заниматься обработкой всех "столкновений" в игре (попадание пули в астероид, столкновение игрока с астероидом, выходы объектов за границы экрана), но пока что мы сделаем только обработку выхода пуль за экран.

```python
def check_collisions(self):            # Метод check_collisions класса Game
    for idx, bullet in enumerate(self.bullets):   # Для каждой пули в игре...
        # ...если центра пули вышел за границы
        if bullet.pos[0] > SCREEN_SIZE[0] or bullet.pos[1] > SCREEN_SIZE[1] or (bullet.pos < 0).any():       
            del self.bullets[idx]      # удалить объект пули
```

Чтобы всё заработало, мы должны добавить вызов этого метода в главный цикл программы.

```python
def run(self):    # Метод run класса Game
    while True:
        self.handle_events()
        self.check_collisions()      # <-----
        print(len(self.bullets))     # <-----
        self.move_objects([[self.starship], self.bullets])
        self.draw([[self.starship], self.bullets])
```

А также будем печатать длину списка пуль, чтобы удостовериться, что всё работает.

Теперь разберём что происходит в методе *check_collisions*.

Для каждой пули (*bullet*), существующей в нашей игре в данный момент (то есть находящейся в списке *self.bullets*) мы проверяем выходит ли каждая из координат её центра из игрового поля. Это значит, что координата *x* должна быть в промежутке от 0 до 600, а координата *у* от 0 до 500 (для экрана размером 600х500). Если хотя бы одно из этих условий было нарушено, нам необходимо удалить пулю из игры. В нашем случае это можно сделать при помощи инструкции *del self.bullets[idx]*. Данная инструкция позволяет безвозвратно удалить практически любой питоновский объект. У вас мог возникнуть вопрос, почему бы вместо этого не воспользоваться методом *self.bullets.remove(bullet)*? Это довольно важный момент, так что мы рассмотрим его отдельно.

 Как же работает *list.remove*? Поскольку класс *list* встроен в python, он написан на С, но можно грубо представить принцип его работы при помощи кода ниже:

```python
# Принимаем на вход список и элемент, который нужно удалить
def remove(lst, item): 
	for index in range(len(lst)):
        if lst[index] == item:
            del lst[index]
            return
```

Мы видим, что для удаления 1 элемента нам нужно пройтись по списку с самого начала до того момента, пока мы не встретим нужный элемент. Затем мы удаляем его при помощи уже знакомого *del*. Как вы уже поняли, *del* работает моментально, а *list.remove* нужно пройти по списку, что занимает в разы больше времени. А теперь представьте, что мы вызываем  *self.bullets.remove(bullet)* в методе *Game.check_collisions*. Для каждой пули которую мы обрабатываем, мы должны будем пройти по списку *self.bullets* **ещё один раз** для того, чтобы удалить пулю (внутри *list.remove*). Использование *del* в этом случае позволит нам довольно сильно ускорить выполнение программы.

Отлично, у нас осталась только одна проблема &mdash; пули вылетаю слишком часто. Логичным решением будет добавить паузу между выстрелами. Допустим, это будет 0.2 секунды, но вы можете задать любой временной промежуток. Запишем это значение в атрибут *fire_rate* в конструкторе класса *Game*.

```python
def  __init__(self, screen):       # Конструктор класса Game
    self.screen = screen         
    self.starship = Starship()
    self.bullets = []
    self.asteroids = []
    self.mouse_pressed = False
    self.fire_rate = 0.2          # <----- Пауза между выстрелами (в секундах)
```

Но как мы будем замерять время? Для этого в питоне есть модуль *time*. В нём есть функция *time.time()*, она возвращает время, прошедшее с 00:00:00 1 Января 1970 года в секундах. 

```python
import time        # Модуль time нужен для замера времени
```

Сама по себе она не даёт нам полезной информации, но мы можем вызвать эту функцию 2 раза и посчитать количество секунд прошедшее между этими вызовами.

Обновим метод *Starship.fire*:

```python
def fire(self):			# Метод fire класса Starship
    self.last_bullet_time = time.time()    # Сохраняем время последнего выстрела
	return Bullet(self.pos.copy())
```

Ранее я упоминал, что метод *Starship.fire* понадобится нам для связывания важного функционала с созданием пули. Этот важный функционал &mdash; сохранение времени последнего выстрела в атрибут *last_bullet_time* объекта класса *Starship*. Оно пригодится нам далее, но для корректной работы нам необходимо также инициализировать этот аргумент в конструкторе.

```python
def __init__(self):     # Конструктор класса Starship
    self.pos = np.array([SCREEN_SIZE[0] / 2, SCREEN_SIZE[1] / 2])
    self.original_image = pygame.image.load(os.path.join("images", "starship.png"))
    self.image = self.original_image
    self.rect = self.image.get_rect(center=self.pos)
    self.last_bullet_time = 0    # <---- Время последнего выстрела

```

Выстрел происходит в методе *Game.handle_events*. До данного момента условием осуществления выстрела являлось только нажатие кнопки мыши. Добавим ещё одно условие. Мы хотим, чтобы время, прошедшее с последнего выстрела (*starship.last_bullet_time*) до текущего момента времени (*time.time()*) было больше времени паузы (*self.fire_rate*).

```python
# Метод handle_events класса Game
# Если кнопка нажата и с последнего выстрела прошло больше self.fire_rate секунд...
if self.mouse_pressed and (time.time() - self.starship.last_bullet_time) > self.fire_rate:                 
 	new_bullet = self.starship.fire()
	self.bullets.append(new_bullet)    
```

Таким образом, мы не сможем делать выстрелы чаще, чем 5 (1/0.2) раз за секунду.

# Добавление астероидов

До сих пор в нашей игре было недостаточно объектов, чтобы в неё можно было играть. Давайте добавим астероиды, которые можно будет разрушать попаданием пули.

Мы хотим, чтобы начальная позиция астероидов и их изображения были случайными. Для генерации случайных чисел мы имортируем модуль *random*.

```python
import random      # Модуль random нужен для генерации случайных чисел
```

Нам будут интересны 2 функции из данного модуля:

* *random.choice*(a) &mdash; возвращает случайный элемент из контейнера *a*.
* *random.uniform(a, b)* &mdash; возвращает случайное число типа float в интервале от *a* до *b*.

Как вы уже догадались, нам нужно описать класс *Asteroid* на основе которого будут создаваться объекты астероидов.

```python
class Asteroid:
    # Оригинальные картинки астероидов
    original_images = [pygame.image.load(os.path.join("images", "ast1_medium.png")),
                       pygame.image.load(os.path.join("images", "ast2_medium.png")),
                       pygame.image.load(os.path.join("images", "ast3_medium.png")),
                       pygame.image.load(os.path.join("images", "ast4_medium.png"))]
    def __init__(self):
        self.image = random.choice(self.original_images)      # Выбираем случайную картинку для астероида
        self.pos = random.choice([self._left_pos, self._top_pos,      # Генерируем случайную начальную позицию
                                  self._right_pos, self._bottom_pos])()
        self.rect = self.image.get_rect(center=self.pos)              # Получаем хитбокс
        self.direction = pygame.mouse.get_pos() - self.pos            # Вычисляем направление
        self.speed = self.direction / 300                             # Расчитываем скорость
        
        
    def _left_pos(self):
        """Генерация позиции слева"""
        return np.array((random.uniform(-100, 0),
                         random.uniform(0, SCREEN_SIZE[1])))

    def _right_pos(self):
        """Генерация позиции справа"""
        return np.array((random.uniform(SCREEN_SIZE[0], SCREEN_SIZE[0] + 100),
                         random.uniform(0, SCREEN_SIZE[1])))

    def _top_pos(self):
        """Генерация позиции сверху"""
        return np.array((random.uniform(0, SCREEN_SIZE[0]),
                         random.uniform(-100, 0)))

    def _bottom_pos(self):
        """Генерация позиции снизу"""
        return np.array((random.uniform(0, SCREEN_SIZE[0]),
                         random.uniform(SCREEN_SIZE[1], SCREEN_SIZE[1] + 100)))


    def move(self):
        self.pos += self.speed
        self.rect = self.image.get_rect(center=self.pos)
```

Теперь разберём код.

Как и в случае класса *Bullet* мы сохраняем картинки в атрибут класса (для того чтобы не загружать их при каждом создании объекта) за тем лишь отличием, что нам нужно несколько картинок (для разнообразия).

При создании объекта (то есть в конструкторе класса) мы делаем следующее:

*self.image = random.choice(self.original_images)* &mdash; выбираем случайную картинку для астероида.

*self.pos = random.choice([self._left_pos, self._top_pos, self._right_pos, self._bottom_pos])()* &mdash; генрация случайной позиции **за пределами** игрового поля. Это необходимо для того, чтобы астероиды появлялись плавно. То есть при создании они не будут видимы для игрока, но при движении они постепенно попадут на игровое поле. Для генерации мы берём случайный элемент из **списка функций**, каждая из которых может генерировать случайную позицию для каждой из 4 сторон игрового поля, а затем вызываем эту функцию. О методах, генерирующих эти позиции, я расскажу позже.

*self.rect = self.image.get_rect(center=self.pos)* &mdash; получаем хитбокс как обычно.

*self.direction = pygame.mouse.get_pos() - self.pos* &mdash; вычисляем направление полёта астероида. Мы видим, что оно выглядит не особо случайно. На это есть ряд причин. Мы могли бы описать отдельный метод, случайно генерирующий направление полёта астероида, но он был бы довольно сложным, так как зависел бы от стороны на которой он бы создавался. Мы легко решаем эту проблему, указывая, что астероид должен лететь **к курсору**. Поскольку мы будем постоянно перемещаться по игровому полю, а значит и курсор будет всё время в разных местах, направление полёта астероидов при увеличении их количества будет казаться случайным. Кроме того, если игрок будет стоять на месте, астероиды будут лететь прямо на него, тем самым вынуждая постоянно двигаться.

*self.speed = self.direction / 300* &mdash; вычисление скорости. Вы могли заметить, что астероиды будут двигаться по той же логике, что и игрок, то есть скорость тем больше, чем больше расстояние до курсора. При большом количестве астероидов это помощет создать иллюзию того, что они все движутся со случайной скоростью.

Методы генерации позиции мы разберём на примере одной из них.

```python
def _left_pos(self):    # Метод _left_pos класса Asteroid
    """Генерация позиции слева"""
    return np.array((random.uniform(-100, 0),
                     random.uniform(0, SCREEN_SIZE[1])))
```

Мы создаём *numpy.array*, содержащий *х* и *у* координаты позиции астероида. При этом важно, что мы генерируем позицию **за пределами** игрового поля, то есть одна из коорданат должна быть отрицательной. Мы берём -100, так как этого достаточно, чтобы при появлении астероида он не задел игрока, пролетающего очень близко к границе игрового поля. Замените -100 на 0 и посмотрите, что произойдёт в таком случае.

Теперь мы готовы создавать астероиды. Давайте добавим их в игру.

Создавать астероиды мы будем с определённой переодичностью (например, каждые 25 кадров), но можно придумать и другие способы. Для этого объявим метод для создания астероидов в классе *Game*.

```python
def cast_asteroid(self):        # Метод cast_asteroid класса Game
    new_asteroid = Asteroid()   # Создаём астероид
    self.asteroids.append(new_asteroid)   # Добавляем его в список всех астероидов
```

 Здесь нет никаких сюрпризов, всё так же как и при создании пуль, но метод мы определили в классе *Game*. Астероиды можно создавать в главном цикле программы, но чтобы не засорять его лишним кодом, опишем создание астероидов в методе *Game.handle_events*. 

```python
def handle_events(self, frame):       # <----- Метод handle_events класса Game
    for event in pygame.event.get(): 
        if event.type == pygame.QUIT: 
            sys.exit()
        if event.type == pygame.MOUSEBUTTONDOWN:
            self.mouse_pressed = True          
        if event.type == pygame.MOUSEBUTTONUP: 
            self.mouse_pressed = False
    if self.mouse_pressed and (time.time() - self.starship.last_bullet_time) > self.fire_rate:
        new_bullet = self.starship.fire()  
        self.bullets.append(new_bullet)
	if frame % 25 == 0:         # <-----   Каждый 25 кадр 
        self.cast_asteroid()    # <-----   Создаём астероид
```

Теперь *Game.handle_events* принимает на вход номер текущего кадра. Считать же кадры мы будем уже в главном цикле. Также мы добавим список астероидов в список объектов на обработку движения и отрисовку.

```python
def run(self):          # Метод run класса Game
    frame = 0       # <-----
    while True:
        self.handle_events(frame)   # <-----
        self.check_collisions()
        self.move_objects([[self.starship], self.bullets, self.asteroids]) # <----
        self.draw([[self.starship], self.bullets, self.asteroids]) # <----
        frame += 1       # <-----
```

Здесь всё просто, мы заводим счётчик кадров *frame* и прибавляем к нему 1 после обработки текущего кадра.

Теперь всё должно работать.

![image-20210327170333080](/home/roman/.config/Typora/typora-user-images/image-20210327170333080.png)

На данном этапе астероиды пока не могут столкнуться с нами и не исчезают при выходе за игровое поле. Это позволяет нам поэкспериментировать с различными параметрами создания астероидов. Например, если не двигать курсором, то мы увидим, что все астероиды пролетают через него. Попробуйте что-нибудь изменить самостоятельно.

Вы также могли заметить, что игра имеет очень быстрый темп. Выходит, что нам нужно поменять параметры скорости у всех объектов? На самом деле нет. Это происходит из-за большого количества **кадров в секунду** (FPS - frames per second). Этот показатель отражает количество игровых кадров, обрабатываемых за 1 секунду. Он может быть очень переменчивым и зависит от количества объектов с которыми работает игра, а также может изменяться в процессе, что будет приводить к изменению темпа. Однако мы хотим, чтобы наша игра работала с постоянной скоростью, то есть мы хотим ограничить показатель *FPS*. 

```python
def run(self):          # Метод run класса Game
    frame = 0
    clock = pygame.time.Clock()   # <-----
    while True:
        clock.tick(60)      # <-----
        self.handle_events(frame)
        self.check_collisions()
        self.move_objects([[self.starship], self.bullets, self.asteroids])
        self.draw([[self.starship], self.bullets, self.asteroids])
        frame += 1
```

Здесь мы создаём специальный объект *Clock*, а затем в главном цикле на каждом кадре вызываем его метод *clock.tick(fps)*, где *fps* &mdash; желаемое количество кадров в секунду. Данный метод гарантирует нам, что между его вызовами пройдёт не меньше 1/60 секунды, а в случае меньшего промежутка времени, функция будет ждать.

Теперь наша игра имеет нормальный темп!
