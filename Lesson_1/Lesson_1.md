# Установка необходимых пакетов

Для написания игры нам понадобится всего 2 библиотеки: numpy и pygame.

Для их установки наберите в терминале/командной строке:

```bash
pip install pygame
pip install numpy
```

# Базовый шаблон игры

Перед вами базовый шаблон практически любой игры на pygame. Давайте разберём, что значат его отдельные части.

```python
import sys         # Модуль sys понадобится нам для закрытия игры
import os          # Модуль os нужен для работы с путями и файлами
import pygame      # Модуль pygame для реализации игровой логики

# Инициализация модуля pygame
pygame.init()
# Цвет фона в формате RGB (красный, синий, зелёный). (0, 0, 0) - чёрный цвет.
BG_COLOR = (0, 0, 0)
# Объект дисплея (0, 0) - полный экран, если задать (800, 600), то окно будет размером 800х600 пикселей
screen = pygame.display.set_mode((0, 0), pygame.RESIZABLE)
# Загрузка картинки звездолёта.
# os.path.join позволяет составлять путь до файла.
starship = pygame.image.load(os.path.join("images", "starship.png"))
# Получаем размеры (хитбокс) картинки
starship_rect = starship.get_rect() 

# Игровой цикл (главный цикл)
while True:
    # Цикл обработки событий (нажатия кнопок, движения мыши и т.д.)
    for event in pygame.event.get():     
        if event.type == pygame.QUIT:    # Нажатие на "Х" на окне программы.
            sys.exit()
        # Обработка других событий

    screen.fill(BG_COLOR)  # Закрасить экран чёрным цветом
    screen.blit(starship, starship_rect)   # Нарисовать изображение на экране "screen" в области "starship_rect"
    pygame.display.update()  # Обновить изображение на экране 
```

При запуске программы с данным кодом мы увидим окно с нашей игрой.

![image-20210323171703145](/home/roman/.config/Typora/typora-user-images/image-20210323171703145.png)

Однако пока что мы не можем перемещать звездолёт или делать делать что-то ещё.

<hr>

Рассмотрим основные объекты текущей реализации игры:

*sceen* &mdash; объект игрового поля. Он имеет ширину и высоту, измеряемые в пикселях. Ширина и высота задаются при создании объекта в виде кортежа из двух чисел. При задании размера (0, 0) объект *screen* получает максимально возможный размер равный разрешению экрана. Флаг *pygame.RESIZABLE* позволит нам произвольно изменять размер окна, а флаг *pygame.FULLSCREEN* развернёт окно на полный экран.

*starship* &mdash; объект, содержащий изображение космического корабля. В дальнейшем он понадобится нам для его отрисовки.

*starship_rect* &mdash; прямоугольник (*RECTangle*), определяющий положение объекта в игровом мире. Его можно задать с помощью координат его вершин или центра, ширины и длины. Данный объект необходим для расчёта столкновений, а также для отрисовки картинок. Можно сказать, что данный прямоугольник является [**Хитбоксом**](https://minecraft-ru.gamepedia.com/%D0%A5%D0%B8%D1%82%D0%B1%D0%BE%D0%BA%D1%81) объекта.

![image-20210323233232417](/home/roman/.config/Typora/typora-user-images/image-20210323233232417.png)

*while True:* &mdash; игровой цикл. Игра по своей сути представляет из себя набор постоянно повторяющихся действий. Для каждого кадра необходимо:

* Обрабатывать все происходящие события (нажатия на кнопки, движение мыши и т.д)
* Проверять столкновения между объектами
* Изменять свойства объектов (перемещение и поворот)
* Отрисовывать объекты на экране

Все перечисленные действия в дальшейшем будут реализованы в игровом цикле, а пока мы имеем только обработку событий и отрисовку.

Пройдёмся подробнее по тому, что происходит в цикле.

```python
for event in pygame.event.get():  # Цикл событий (для каждого события event...)
    # Обработчик события (...если event это закрытие окна программы)
    if event.type == pygame.QUIT: 
        sys.exit()      # Завершение работы программы
```

*pygame.event.get()* способен выдавать нам происходящие в данный момент события *event*.

*event* &mdash; событие ввода/вывода. Оно имеет различные атрибуты в зависимости от своего типа (*event.type*). Например, для *event.type == pygame.MOUSEMOTION* доступны атрибуты *pos* (координаты курсора), *rel* (направление в котором смотрит курсор) и *buttons* (состояние кнопок мыши). Список атрибутов для каждого типа событий можно найти [здесь](https://www.pygame.org/docs/ref/event.html). *pygame.QUIT* в свою очередь означает нажатие на кнопку закрытия окна программы (если данное поведение не определить, то игру нельзя будет закрыть таким образом). 

*sys.exit()* &mdash; функция из модуя *sys* стандартной библиотеки. При её вызове происходит завершение работы программы.

```python
screen.fill(BG_COLOR)
screen.blit(starship, starship_rect)
pygame.display.update()
```

Код, приведённый выше, занимается отрисовкой игровых объектов. Для этого нам необходим объект игрового поля (*screen*), а также картинка (*starship*) и её хитбокс (*starship_rect*). Данный набор будет небходим для отрисовки **каждого** объекта в нашей игре.

*screen.fill(BG_COLOR)* &mdash; заливает экран заданным цветом. Позже, при написании логики движения корабля, мы поймём почему это необходимо.

*screen.blit(starship, starship_rect)* &mdash; "отрисовывает" *starship* в области игрового поля (*screen*), заданной хитбоксом *starship_rect*. После данной операции *screen* уже содержит информацию о том, что нужно отобразить на экране, однако за непосредственно вывод на экран отвечает *pygame.display.update()*.

# Работа с классами

До этого момента мы часто оперировали понятием "объект" для обозначения предметов в игре, не придавая этому особого значения. Но на самом деле, для реализации подобного проекта будет очень удобно пользоваться *объектами* как некоторой программной сущностью. Мы можем представить все предметы в нашей игре в виде однотипных *объектов*, которые смогут совершать действия, определяемые их *классом*, а также иметь набор *свойств* (или *атрибутов*). Давайте разберёмся во всём этом, перенося наш базовый шаблон на работу с классами:

Для начала просто посмотрите на код, дальше будут даны необходимые разъяснения.

```python
import sys      
import os          
import pygame      
import numpy as np


pygame.init() 
BG_COLOR = (0, 0, 0)
screen = pygame.display.set_mode((600, 500), pygame.RESIZABLE)
# Получим ширину и высоту игрового поля из объекта screen и сохраним в глобальную переменную.
# Мы будем использовать SCREEN_SIZE очень часто!
SCREEN_SIZE = screen.get_size()


class Game:
    """Основной класс игры. В нём представлены основные методы для управления игровыми объектами, а также сами объекты"""
    def  __init__(self, screen):     
        self.screen = screen         
        self.starship = Starship()  # Объект класса Starship (игрок)
        self.bullets = []           # Заготовка для хранения объектов пуль
        self.asteroids = []         # Заготовка для хранения объектов астероидов

    def handle_events(self):
    	"""Метод - обработчик событий. Выполняет те же действия, что и в базовом шаблоне"""
        for event in pygame.event.get(): 
            if event.type == pygame.QUIT: 
                sys.exit()

    def draw(self, objects_list):
    	"""Метод отрисовки объектов. Переносит на игровое поле все объекты переданные ему внутри аргумена objects_list"""
        screen.fill(BG_COLOR)
        for objects in objects_list:
            for obj in objects:
            	self.screen.blit(obj.image, obj.rect)
        pygame.display.update()

    def run(self):
    	"""Главный цикл программы. Вызывается 1 раз за игру"""
        while True:
            self.handle_events()
            self.draw([[self.starship]])

class Starship:
    """Класс представляющий игрока"""
	def __init__(self):
    	# Текущие координаты (в пикселях)
		self.pos = np.array([SCREEN_SIZE[0] / 2, SCREEN_SIZE[1] / 2])
    	# Оригинальное изображение
		self.original_image = pygame.image.load(os.path.join("images", "starship.png"))
    	# Изображение для отрисовки
		self.image = self.original_image
    	# Границы модельки корабля (хитбокс)	
		self.rect = self.image.get_rect(center=self.pos)     


game = Game(screen)     # Создание и запуск игры
game.run()
```

Вам могло показаться, что код стал намного сложнее, но я постараюсь убедить вас, что это не так! Хотя код и стал длиннее, теперь мы имеем гораздо больше возможностей по его расширению и поддержке.

Начнём и класса *Game*. Класс *Game* - основной и самый главный класс в этой игре. Объект класса *game* будет управлять всеми игровыми событиями при помощи соответствующих методов. Давайте рассмотрим его конструктор:

```python
def  __init__(self, screen):     
    self.screen = screen         
    self.starship = Starship()
    self.bullets = []
    self.asteroids = []
```

В качестве аргумента конструктор принимает объект игрового поля и сохраняет его в соответствующий атрибут (*self.screen*).

Далее мы видим атрибуты, которые будут хранить игровые объекты. *self.starship* - объект корабля, *self.asteroids* &mdash; список из всех астероидов в игре. Сохранение всех игровых объектов в атрибуты позволит нам быстро и удобно получать к ним доступ из любого метода класса *Game*.

 ```python
def handle_events(self):
    for event in pygame.event.get(): 
        if event.type == pygame.QUIT: 
            sys.exit()
 ```

Мы перенесли обработчик событий в отдельный метод, принцип его работы не изменился.

```python
def draw(self, objects_list):
    screen.fill(BG_COLOR)
    for objects in objects_list:
        for obj in objects:
            self.screen.blit(obj.image, obj.rect)
    pygame.display.update()
```

Здесь мы вынесли код, который отрисовывает объекты в отдельный метод при этом добавив поддержку работы сразу со многими объектами. В качестве аргумента метод принимает *objects_list*. Забегая вперёд, скажу, что он будет иметь вид:

`[[self.starship], self.bullets, self.asteroids]`

Метод будет проходить по соответствующим спискам и отрисовывать объекты, находящиеся там. При этом важно заметить, что объекты должны иметь атрибуты *self.image* (картинка) и *self.rect* (хитбокс). В противном случае возникнет ошибка. Так что на наши плечи ложатся обязанности по реализации данных атрибутов у всех классов. 

```python
def run(self):
    while True:
        self.handle_events()
        self.draw([[self.starship]])
```

Метод *run* будет заключать в себе главный цикл программы. Благодаря тому, что мы уже перенесли весь оставшийся код в методы класса *Game*, главный цикл будет иметь всего 2 строки. При этом мы уже можем абстрагироваться от деталей реализации *self.handle_events* и *self.draw*. 

Возможно вы заметили, что мы передаём *self.starship* в списке из одного элемента. Почему же так? Это необходимо для сохранения логики работы *self.draw*. Данный метод ожидает список списков в качестве аргумента и мы непременно получим ошибку передав ему другую структуру данных. Таким образом мы как бы "обманываем" метод, передавая ему список космических кораблей, которых никогда не будет больше, чем один.

Пора рассмотреть класс *Starship*.

```python
class Starship:
	def __init__(self):
		self.pos = np.array([SCREEN_SIZE[0] / 2, SCREEN_SIZE[1] / 2])
		self.original_image = pygame.image.load(os.path.join("images", "starship.png"))
		self.image = self.original_image
        self.speed = np.array([0.0, 0.0])
		self.rect = self.image.get_rect(center=self.pos)
```

На примере этого класса мы разберём общее устройство всех объектов в нашей игре. Рассмотрим по порядку 5 основных и самых важных атрибутов.

*self.pos* &mdash; текущие координаты корабля. Представляет из себя *numpy array* с двумя элементами - координатами объекта по осям *х* и *у*. *np.array* будет очень сильно полезен при расчёте движения объектов.  При создании объекта звездолёта мы задаём *self.pos* равным координатам центра игрового поля, предварительно определив глобальную константу *SCREEN_SIZE*, содержащую ширину и высоту игрового поля.

*self.original_image* &mdash; оригинальное изображение, которое никак не будет изменяться в ходе игры. На основе него будут создаваться изменённые варианты изображения (например, повёрнутые). Такие картинки мы будем сохранять в атрубут *self.image*.

*self.speed* &mdash; вектор скорости объекта. Представляет из себя *numpy array* с двумя элементами - величинами изменения координат объекта при движении.

 <hr>

Базовый пример реализации движения:

```python
>>> self.pos = np.array([10, 20])
>>> self.speed = np.array([-1, 3])
>>> self.pos += self.speed
>>> print(self.pos)
array([9, 23])
```

Объект сдвинулся на 1 пиксель влево и на 3 вниз.

<hr>

*self.rect* &mdash; хитбокс объекта. При получении хитбокса из картинки очень важно задавать центр хитбокса равным позиции объекта, иначе он может окажется в начале координат.

Наконец, для запуска игры мы должны создать объект класса *Game* и вызвать у него метод *run*.

```python
game = Game(screen)
game.run()
```

Теперь при запуске игры мы видим следующую картину:

![image-20210323174618258](/home/roman/.config/Typora/typora-user-images/image-20210323174618258.png)

Значительных изменений не произошло, но с готовым шаблоном на основе классов всё теперь пойдёт намного проще и быстрее.

# Добавление движения

У нас есть шаблон для нашей игры, но ничего интересного пока не происходит. Давайте заставим звездолёт двигаться за курсором.

Для этого создадим метод *move* у класса *Starship* и опишем соответствующее поведение:

```python
def move(self):                       # Starship.move
    mouse_pos = pygame.mouse.get_pos()    # Текущая позиция курсора мыши
    direction = mouse_pos - self.pos      # Текущее направление
    self.speed = direction / 40           # Новое значение скорости
    self.pos += self.speed                # Движение - обновление координат
    self.rect = self.image.get_rect(center=self.pos) # Перемещение хитбокса
```

*mouse_pos* &mdash; *numpy array* c текущими координатами курсора на игровом поле.

*direction* &mdash; вектор, направленный от звездолёта к курсору. Значения *direction* тем больше, чем дальше курсор от корабля.

*self.speed = direction / 40* &mdash; вектор скорости должен быть направлен от звездолёта в сторону курсора, так как мы хотим, чтобы звездолёт летел именно туда. Заметим, что вектор *direction* направлен в ту же сторону. Почему бы тогда не использовать его вместо скорости? Проблема в том, что координаты *direction* будут измеряться в сотнях пикселей, а значит каждый кадр позиция звездолёта будет изменяться на 100+ пикселей, что слишком быстро. Для того чтобы этого избежать мы поделим *direction* на какое-нибудь число. Это позволит сохранить направление и существенно снизить скорость.

*self.pos += self.speed* &mdash; здесь непосредственно происходит движение, координаты меняются на новые.

*self.rect = self.image.get_rect(center=self.pos)* &mdash; обновление хитбокса для новых координат.

<hr>

Чтобы лучше понять какие операции происходят с векторами в методе *Game.move*, можно рассмотреть схему (для окна размером 600х500):

![image-20210324000220598](/home/roman/.config/Typora/typora-user-images/image-20210324000220598.png)

<hr>

Мы научили объект класса *Starship* двигаться. Теперь нужно дать возможность классу *Game* контролировать это. Объявим новый метод *move_objects*.

```python
def move_objects(self, objects_list):     # Game.move_objects
    for obj_idx, _ in enumerate(objects_list):  # Перебор групп объектов (asteroids, bullets)
        for o_idx, _ in enumerate(objects_list[obj_idx]): # Перебор объектов внутри групп
            objects_list[obj_idx][o_idx].move()   # Перемещение объекта
```

Данный метод будет перемещать все объекты переданные внутри аргумента *objects_list*. Стоит заметить, что его реализация очень похожа на метод *draw*. Различия состоят в том, что нам важно именно **изменить** объекты (перемещение это по сути изменение позиции), а для этого нам необходимо обратиться к объекту по индексу. А также, как вы уже заметили, для перемещения объект должен обладать методом *move*, причём его реализация может кардинально отличаться у разных объектов, а в рамках данного метода для нас детали этой реализации совершенно не важны.

Теперь мы можем поместить вызов данного метода в игровой цикл:

```python
def run(self):
    while True:
        self.handle_events()
        self.move_objects([[self.starship]])  # <-------
        self.draw([[self.starship]])
```

Теперь для каждого кадра у нас сначала происходит обработка событий, которые мы пока что ещё не задали, перемещение всех объектов и их отрисовка. 

Отлично, теперь корабль двигается за курсором. Помните, я писал, что мы вернёмся к строчке *screen.fill(BG_COLOR)* в методе *Game.draw*? Теперь, когда у нас есть звездолёт, который может двигаться, попробуем закомментировать эту строку.

```python
def draw(self, objects_list):      # Game.draw
    # screen.fill(BG_COLOR)
    for objects in objects_list:
        for obj in objects:
            self.screen.blit(obj.image, obj.rect)
    pygame.display.update()
```

Запустив игру, мы увидим следующий эффект:

![image-20210323205750208](/home/roman/.config/Typora/typora-user-images/image-20210323205750208.png)



Он возникает из-за того, что на каждом кадре происходит отрисовка объектов на игровое поле из предыдущего кадра. То есть всё, что когда-либо было нарисовано &mdash; сохраняется. *screen.fill(BG_COLOR)* на каждом кадре заливает экран чёрным цветом. Это позволяет нам "забыть" про то, что было на предыдущем кадре и рисовать на чистом поле. 

На самом деле, движение звездолёта &mdash; всего лишь оптическая иллюзия. Десятки раз за одну секунду отрисовывается совершенно новая картинка, на которой расположение объектов совсем немного отличается, но наш мозг и глаза не способны уловить столь мельчайшие детали, поэтому нам кажется, что звездолёт движется непрерывно.

# Поворот за курсором

Наш звездолёт может двигаться, но из-за того что он всё время смотрит в одну сторону, это выглядит нелепо. Давайте добавим возможность поворота в сторону курсора.

Для начала импортируем модуль *math* из стандартной библиотеки.

```python
import math     # Модуль math будет полезен для вычисления угла наклона звездолёта
```

Для того чтобы повернуть объект нам нужно знать угол на который его поворачивать. Углы чаще всего измеряются в двух величинах: *градусах* и *радианах*.  В то время как градусы более привычны нам в бытовом использовании, радианы повсеместно используются в различных математических расчётах. 1 рад = 57.2958 град.  Для перевода этих величин из одной в другую можно воспользоваться онлайн-конвертерами или следующими формулами:

​																**град** =  рад × 180/π

​														    	**рад** =  (град × π)/180

Нам нужно знать угол наклона звездолёта в каждый момент времени, поэтому произведём необходимые расчёты внутри метода *Starship.move*, который выполняется на каждом кадре.

```python
def move(self):                       # Starship.move
    mouse_pos = pygame.mouse.get_pos()
    direction = mouse_pos - self.pos
    angle = self.calculate_angle(mouse_pos)   # <----- Расчёт угла наклона корабля
    self.pos += self.speed
    # Вращение картинки
    self.image = pygame.transform.rotate(self.original_image, int(angle)) # <-----
    self.rect = self.image.get_rect(center=self.pos)
```

Мы добавили две новые строки в метод *Starship.move*. При модификации имеющегося кода всегда следите за тем, чтобы последовательность действий сохраняла требуемую логику.

*angle* &mdash; угол наклона звездолёта в градусах, для его расчёта мы вызываем метод *Starship.calculate_length*, чтобы не засорять метод *move* не относящейся к нему логикой. Этот метод мы опишем чуть позже.

*self.image = pygame.transform.rotate(self.original_image, int(angle))* &mdash; здесь непосредственно происходит поворот, а именно создание **новой** картинки (повёрнутой на *angle* градусов) на основе **оригинальной**. Для того чтобы наконец понять для чего нужна оригинальная картинка, попробуйте заменить *self.original_image* на *self.image*.

Но всё это не будет работать пока мы не определим метод *Starship.calculate_angle*.

```python
def calculate_angle(self, mouse_pos):     # Starship._calculate_angle
    rel_x, rel_y = mouse_pos - self.pos   # x и у составляющие вектора направления
    angle = (180 / math.pi) * -math.atan2(rel_y, rel_x) + 90  # Расчёт угла
    return angle
```

Для начала нам нужно получить x и у составляющие вектора направления (*direction*). Зная эти две величины мы можем расчитать **тангенс** угла, катетами которого они являются. Но тангенс это не угол, для расчёта величины угла (в радианах) нам понадобится **арктангенс**. Полученный угол затем нужно перевести в градусы (т. к. *pygame.transform.rotate* принимает градусы) умножив арктангенс на *180/π*.

Заметьте, что мы добавили 90 град к полученному углу. Попробуйте убрать это значение и посмотреть, что получится.

<hr>

Ниже есть схема для особо интересующихся, но запоминать это не обязательно.

![image-20210324013246859](/home/roman/.config/Typora/typora-user-images/image-20210324013246859.png)

Функция *math.atan2* возвращает угол от π до -π рад, переведя его в градусы мы получим наклон относительно оси Х. При этом если знак угла положительный, то наклон будет против часовой стрелки, а если отрицательный, то по часовой стрелке.

<hr>

Замечательно! Теперь наш звездолёт летает так, как мы этого хотели.

На следующем занятии мы добавим возможность стрельбы по нажатию кнопки мыши, а также астероиды.

# Домашнее задание

Для того, чтобы лучше разобраться в том, что происходит в нашем коде, я советую вам поварьировать различные параметры. Ниже приведён список вопросов, для каждого из них внесите соответствующие изменения в код, опишите, как изменяется игровой процесс, и предположите, почему мы наблюдаем те или иные изменения.

*Что будет если убрать sys.exit() (заменить на pass) в обработчике событий? Как выйти из игры в таком случае?*

*Что будет если в методе Game.move_objects не обращаться по индексу, а итерироваться напрямую по объектам? Попробуйте объяснить причину такого результата.*

*Что если в методе Starship.move при получении нового хитбокса убрать аргумент center=self.pos?*

*Попробуйте варьировать число на которое мы делим direction при расчёте скорости в методе Starship.move. Что происходит при очень больших и маленьких значениях?*

*Попробуйте убрать атрибут original_image из класса Starship, а вместо него везде подставьте self.image. Как вы думаете, что произошло?*

*Что будет если не добавлять 90 град при расчете угла поворота звездолёта в методе Starship.calculate_angle? Почему именно 90?*

*Попробуйте загрузить собственную картинку вместо звездолёта.*